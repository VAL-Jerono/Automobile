"""
RAG (Retrieval-Augmented Generation) query endpoints.
"""

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import List, Dict, Any
import logging
from api.dependencies import get_rag_engine, get_rag_generator

logger = logging.getLogger(__name__)
router = APIRouter()

class RAGQueryRequest(BaseModel):
    query: str
    query_type: str = "policy"  # policy, claims, general
    top_k: int = 5

class RAGResult(BaseModel):
    rank: int
    score: float
    metadata: Dict[str, Any]
    snippet: str

class RAGQueryResponse(BaseModel):
    query: str
    results: List[RAGResult]
    total_results: int
    search_time_ms: float

@router.post("/query", response_model=RAGQueryResponse)
async def query_rag(req: RAGQueryRequest):
    """
    Retrieve similar policies, claims, or general insurance context using semantic search.
    """
    try:
        import time
        start_time = time.time()
        
        rag = get_rag_engine()
        
        if req.query_type == "policy":
            raw_results = rag.query_policies(req.query, top_k=req.top_k)
        elif req.query_type == "claims":
            raw_results = rag.query_claims(req.query, top_k=req.top_k)
        else:
            raw_results = []  # Implement general query
        
        logger.info(f"RAG Query: '{req.query}' -> Found {len(raw_results)} results")
        
        # Format results
        results = [
            RAGResult(
                rank=r['rank'],
                score=r['similarity'],
                metadata={k: v for k, v in r.items() if k not in ['rank', 'similarity', 'document']},
                snippet=r['document'][:200]
            )
            for r in raw_results
        ]
        
        elapsed_ms = (time.time() - start_time) * 1000
        
        return RAGQueryResponse(
            query=req.query,
            results=results,
            total_results=len(results),
            search_time_ms=elapsed_ms
        )
    
    except Exception as e:
        logger.error(f"RAG query failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

class PolicyRecommendationRequest(BaseModel):
    policy_id: int
    context: str  # e.g., "similar_policies", "claims_patterns", "risk_assessment"

class RecommendationResponse(BaseModel):
    policy_id: int
    recommendations: List[str]
    supporting_evidence: List[Dict[str, Any]]

@router.post("/recommendations", response_model=RecommendationResponse)
async def get_policy_recommendations(req: PolicyRecommendationRequest):
    """
    Get personalized recommendations using RAG and historical context.
    """
    try:
        rag = get_rag_engine()
        
        # Query similar policies
        query = f"policies similar to {req.policy_id}"
        results = rag.query_policies(query, top_k=3)
        
        recommendations = [
            "Review coverage limits based on similar claims",
            "Consider bundling options for cost savings",
            "Update vehicle information for accurate pricing"
        ]
        
        return RecommendationResponse(
            policy_id=req.policy_id,
            recommendations=recommendations,
            supporting_evidence=[r for r in results]
        )
    
    except Exception as e:
        logger.error(f"Recommendation generation failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))

class AskRequest(BaseModel):
    query: str
    filters: Dict[str, Any] = {}

class AskResponse(BaseModel):
    answer: str
    sources: List[Dict[str, Any]]
    model_used: str

@router.post("/ask", response_model=AskResponse)
async def ask_rag(req: AskRequest):
    """
    Ask a natural language question and get an answer generated by the LLM based on retrieved context.
    """
    try:
        rag_engine = get_rag_engine()
        rag_generator = get_rag_generator()
        
        # 1. Retrieve Context
        # Try both policies and claims to get broad context
        policy_results = rag_engine.query_policies(req.query, top_k=3)
        claim_results = rag_engine.query_claims(req.query, top_k=3)
        
        # Combine and deduplicate context
        context_docs = policy_results + claim_results
        
        # 2. Generate Answer
        result = rag_generator.generate_answer(req.query, context_docs)
        
        if "error" in result:
            raise HTTPException(status_code=503, detail=result["error"])
            
        return AskResponse(
            answer=result.get("answer", ""),
            sources=result.get("sources", []),
            model_used=result.get("model_used", "unknown")
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"RAG ask failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))
